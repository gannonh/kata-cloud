---
phase: 07-resume-integrity-and-context-consistency
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/main/persisted-state-store.ts
  - src/main.tsx
autonomous: true

must_haves:
  truths:
    - "App restart transitions in-flight runs (queued or running) to interrupted status before broadcasting state to renderer"
    - "User sees interrupted runs labeled distinctly from active or completed runs in the orchestrator view"
    - "Each new orchestrator run captures and persists the resolved context provider identity"
    - "User can see which context provider and snippet count informed each run's output"
    - "Stale interrupted artifacts are visually distinguishable from current active workflow state"
  artifacts:
    - path: "src/main/persisted-state-store.ts"
      provides: "recoverInterruptedRuns() called during initialize() before state broadcast"
    - path: "src/main.tsx"
      provides: "resolvedProviderId capture on run creation, interrupted status rendering, provenance display"
  key_links:
    - from: "src/main/persisted-state-store.ts"
      to: "src/shared/state.ts"
      via: "Uses OrchestratorRunRecord with interrupted status and interruptedAt field"
      pattern: "status.*interrupted"
    - from: "src/main.tsx"
      to: "src/context/context-adapter.ts"
      via: "resolveContextProviderId called before run enqueue"
      pattern: "resolveContextProviderId"
    - from: "src/main.tsx"
      to: "src/shared/orchestrator-run-view-model.ts"
      via: "contextProvenance field rendered in run status/history sections"
      pattern: "contextProvenance"
---

<objective>
Wire interrupted-run recovery into main process startup and add provenance capture + display in the renderer.

Purpose: Complete the runtime integration so users see recovered interrupted runs after restart (SESS-01/02/03), context provenance per run (CTX-03/04), and clear distinction between stale and active artifacts.
Output: Main process startup recovery, renderer run creation with provenance capture, and UI rendering for interrupted status and context provenance.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/pending/07-resume-integrity-and-context-consistency/07-01-PLAN.md
@src/main/persisted-state-store.ts
@src/shared/state.ts
@src/shared/orchestrator-run-view-model.ts
@src/context/context-adapter.ts
@src/main.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add interrupted-run recovery to PersistedStateStore startup</name>
  <files>
    src/main/persisted-state-store.ts
  </files>
  <action>
1. In `src/main/persisted-state-store.ts`:
   - Add a private method `recoverInterruptedRuns()`:
     ```typescript
     private async recoverInterruptedRuns(): Promise<void> {
       const now = new Date().toISOString();
       const runs = this.state.orchestratorRuns;
       const hasInFlight = runs.some(
         (run) => run.status === "queued" || run.status === "running"
       );
       if (!hasInFlight) return;

       const recovered = runs.map((run) =>
         run.status === "queued" || run.status === "running"
           ? {
               ...run,
               status: "interrupted" as const,
               statusTimeline: [...run.statusTimeline, "interrupted" as const],
               interruptedAt: now,
               updatedAt: now
             }
           : run
       );
       this.state = { ...this.state, orchestratorRuns: recovered };
       await this.writeToDisk(this.state);
     }
     ```
   - Update `initialize()` to call recovery after reading from disk:
     ```typescript
     async initialize(): Promise<AppState> {
       this.state = await this.readFromDisk();
       await this.recoverInterruptedRuns();
       return this.state;
     }
     ```
   - Import `OrchestratorRunStatus` type if needed for the `as const` assertions to work cleanly. The existing imports from `"../shared/state"` already cover `AppState`, `createInitialAppState`, and `normalizeAppState`. The `"interrupted"` literal will satisfy the `OrchestratorRunStatus` type after Plan 01 extends it.

Note: This recovery runs BEFORE the main process broadcasts state via `did-finish-load`, so the renderer never sees stale "running" records. The `writeToDisk` call ensures the recovery is durable even if the app crashes again before the next save.
  </action>
  <verify>
    `pnpm run desktop:typecheck` passes.
    Manual verification: The recovery logic is structurally verifiable by reading the code. The main process test infrastructure does not support unit-testing PersistedStateStore (it depends on Electron `app` module), but the contract correctness is guaranteed by Plan 01's shared tests for interrupted normalization round-trip.
  </verify>
  <done>
    `PersistedStateStore.initialize()` scans for in-flight runs and transitions them to `"interrupted"` with `interruptedAt` timestamp before returning state. Recovery writes to disk immediately. Typecheck clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Capture resolvedProviderId on run creation and render interrupted + provenance in UI</name>
  <files>
    src/main.tsx
  </files>
  <action>
1. **Capture resolvedProviderId on run creation:**
   - In the `onRunOrchestrator` handler (around line 913 where the run is enqueued), after resolving the context provider via `resolveContextProviderId(activeSpace.contextProvider, activeSession.contextProvider)`, store the result as `resolvedProviderId` on the initial `OrchestratorRunRecord` object passed to `enqueueOrchestratorRun`. The enqueued run object should include `resolvedProviderId: contextProviderId` (where `contextProviderId` is the resolved value).
   - Verify `resolveContextProviderId` is already imported from `"./context/context-adapter"`. If not, add the import.

2. **Render interrupted status in latest run and run history:**
   - In the orchestrator latest-run status section, ensure the `statusLabel` from the view model is displayed (it already should be). The view model now returns `"Interrupted"` for interrupted runs (from Plan 01).
   - Add a visual distinction for interrupted runs in the history list. When `run.status === "interrupted"`, render the status with an annotation such as "(app exited)" after the label. Use existing error styling patterns (e.g., the same text color or CSS class used for failed runs, or a muted/warning variant). Keep it minimal: the status label `"Interrupted"` plus the annotation is sufficient.

3. **Render context provenance in run status/history:**
   - In the orchestrator status section (latest run display), if `viewModel.contextProvenance` is defined, render a provenance line below the context preview. Format: `"Context: {resolvedProviderId} ({snippetCount} snippets)"`. If `fallbackFromProviderId` is defined, append `" (fallback from {fallbackFromProviderId})"`.
   - In the run history list items, include the same provenance summary as a secondary line when `contextProvenance` is present.
   - Keep the provenance display compact. Use existing info-level text styling. Do not introduce new CSS classes unless needed for the interrupted annotation.

Important constraints:
- Do NOT restructure the existing orchestrator view layout. Add provenance and interrupted rendering inline with existing patterns.
- The `resolvedProviderId` field is optional on the record, so always guard with `?.` or conditional checks.
- Existing runs without `resolvedProviderId` should render without provenance (graceful degradation).
  </action>
  <verify>
    `pnpm run desktop:typecheck` passes.
    `pnpm test` passes (no renderer test regressions).
  </verify>
  <done>
    New orchestrator runs persist `resolvedProviderId`. Interrupted runs display as "Interrupted (app exited)" in status and history views. Context provenance (provider, snippet count, fallback indicator) is visible for runs that have `resolvedProviderId`. Existing runs without provenance data render without errors. Typecheck and tests pass.
  </done>
</task>

</tasks>

<verification>
- `pnpm test` passes (full suite including shared and renderer tests).
- `pnpm run desktop:typecheck` passes.
- After Plan 01 + Plan 02: interrupted-run recovery is wired end-to-end from main process startup through renderer display.
- Context provenance is captured at run creation and visible in the orchestrator UI.
</verification>

<success_criteria>
- PersistedStateStore startup transitions in-flight runs to interrupted before broadcasting.
- Renderer captures and persists resolvedProviderId on new runs.
- Interrupted runs render with distinct label and annotation in both latest-run and history views.
- Context provenance (provider, snippet count, fallback) renders for runs with resolvedProviderId.
- All tests pass, typecheck clean.
</success_criteria>

<output>
After completion, create `.planning/phases/pending/07-resume-integrity-and-context-consistency/07-02-SUMMARY.md`
</output>

---
phase: 05-orchestrator-lifecycle-determinism
plan: 03
type: execute
wave: 2
depends_on:
  - "01"
  - "02"
files_modified:
  - src/main.tsx
  - src/shared/orchestrator-state.test.ts
  - src/shared/state.test.ts
autonomous: true
source_issue: github:#58
must_haves:
  truths:
    - Running a prompt always progresses through deterministic run lifecycle states in persisted app state.
    - Delegated-task status and failure diagnostics shown in orchestrator UI come from shared projection helpers.
    - Terminal run outcomes are persisted with consistent lifecycle timelines and actionable error context.
  artifacts:
    - src/main.tsx
    - src/shared/orchestrator-state.test.ts
    - src/shared/state.test.ts
  key_links:
    - Renderer `onRunOrchestrator` flow uses shared lifecycle helper(s) from Plan 01.
    - Renderer status panels/history consume shared run projection output from Plan 02.
    - Persisted state fixtures in shared tests reflect deterministic lifecycle and task-status semantics.
---

<objective>
Integrate deterministic lifecycle and shared run-status projection into orchestrator execution + UI flow.

Purpose: Deliver ORCH-01 and ORCH-02 user-visible behavior with minimal monolith risk by wiring already-tested shared helpers.
Output: `src/main.tsx` orchestrator flow and status panels consume shared lifecycle/projection helpers with regression coverage updates.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/pending/05-orchestrator-lifecycle-determinism/05-RESEARCH.md
@.planning/phases/pending/05-orchestrator-lifecycle-determinism/05-01-PLAN.md
@.planning/phases/pending/05-orchestrator-lifecycle-determinism/05-02-PLAN.md
@src/main.tsx
@src/shared/orchestrator-state.test.ts
@src/shared/state.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire shared lifecycle transition helper into orchestrator run execution flow</name>
  <files>src/main.tsx</files>
  <action>Refactor `onRunOrchestrator` status transitions to call Plan 01 lifecycle helper(s) for queued -> running -> terminal progression. Preserve current context retrieval/delegation flow, but eliminate duplicated inline lifecycle mutation where helper coverage exists.</action>
  <verify>pnpm test -- orchestrator</verify>
  <done>Run execution path uses shared lifecycle helper(s) for all run status mutations and maintains deterministic timelines in persisted state.</done>
</task>

<task type="auto">
  <name>Task 2: Replace ad-hoc status rendering with shared run view-model projections</name>
  <files>src/main.tsx</files>
  <action>Update latest-run and run-history rendering blocks to consume Plan 02 projection output for lifecycle text and delegated-task failure context. Keep UI structure intact while reducing duplicated status formatting logic in JSX.</action>
  <verify>pnpm test -- orchestrator</verify>
  <done>Orchestrator status panels and run-history rows render deterministic status/failure diagnostics sourced from shared projection helpers.</done>
</task>

<task type="auto">
  <name>Task 3: Update regression fixtures for deterministic lifecycle semantics</name>
  <files>src/shared/orchestrator-state.test.ts, src/shared/state.test.ts</files>
  <action>Adjust and expand shared-state fixture tests to assert deterministic lifecycle/timeline behavior after renderer wiring changes, including failed delegation chains and terminal-state persistence expectations.</action>
  <verify>pnpm test -- orchestrator && pnpm test -- state</verify>
  <done>Shared regression suites cover the new deterministic lifecycle + projection integration paths with passing assertions.</done>
</task>

</tasks>

<verification>
1. Run `pnpm test -- orchestrator`.
2. Run `pnpm test -- state`.
3. Run `pnpm run desktop:typecheck`.
</verification>

<success_criteria>
- ORCH-01: deterministic run lifecycle progression is enforced by shared helpers and persisted consistently.
- ORCH-02: delegated-task status/failure context renders consistently from shared projection output.
- Renderer integration avoids broad unrelated UI churn and keeps phase scope constrained.
</success_criteria>

<output>
After completion, create `.planning/phases/pending/05-orchestrator-lifecycle-determinism/05-03-SUMMARY.md`
</output>
